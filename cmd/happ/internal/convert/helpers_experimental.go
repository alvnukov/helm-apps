package convert

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/zol/helm-apps/cmd/happ/internal/config"
)

func BuildValuesHelpersExperimental(cfg config.Config, docs []map[string]any) (map[string]any, error) {
	values := map[string]any{
		"global": map[string]any{"env": cfg.Env},
	}

	statelessGroup := map[string]any{}
	configmapsGroup := map[string]any{}
	secretsGroup := map[string]any{}
	servicesGroup := map[string]any{}
	ingressesGroup := map[string]any{}
	netpolGroup := map[string]any{}
	serviceAccountsGroup := map[string]any{}
	jobsGroup := map[string]any{}
	cronjobsGroup := map[string]any{}
	var rawFallbackDocs []map[string]any
	statelessByName := map[string]map[string]any{}
	serviceAccountsByNSName := map[string]map[string]any{}
	var pendingPDB []map[string]any
	var pendingSA []map[string]any
	var pendingRoles []map[string]any
	var pendingRoleBindings []map[string]any
	var pendingClusterRoles []map[string]any
	var pendingClusterRoleBindings []map[string]any

	// Pass 1: map workloads first so related resources can attach to them later.
	for _, doc := range docs {
		switch kindOf(doc) {
		case "Deployment":
			appKey, app, ok := mapDeploymentToAppsStateless(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			key := dedupeGroupKey(statelessGroup, appKey)
			statelessGroup[key] = app
			if n, _ := app["name"].(string); n != "" {
				statelessByName[metadataNamespace(doc)+"/"+n] = app
			}
		}
	}

	// Pass 2: map independent resources and attach related ones.
	for _, doc := range docs {
		switch kindOf(doc) {
		case "Deployment":
			continue // already handled
		case "ConfigMap":
			appKey, app, ok := mapConfigMapToAppsConfigmaps(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			configmapsGroup[dedupeGroupKey(configmapsGroup, appKey)] = app
		case "Secret":
			// Try library-native Secret first, but avoid remapping service-account tokens generated by k8s.
			appKey, app, ok := mapSecretToAppsSecrets(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			secretsGroup[dedupeGroupKey(secretsGroup, appKey)] = app
		case "Service":
			appKey, app, ok := mapServiceToAppsServices(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			servicesGroup[dedupeGroupKey(servicesGroup, appKey)] = app
		case "Ingress":
			appKey, app, ok := mapIngressToAppsIngresses(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			ingressesGroup[dedupeGroupKey(ingressesGroup, appKey)] = app
		case "NetworkPolicy":
			appKey, app, ok := mapNetworkPolicyToAppsNetworkPolicies(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			netpolGroup[dedupeGroupKey(netpolGroup, appKey)] = app
		case "Job":
			appKey, app, ok := mapJobToAppsJobs(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			jobsGroup[dedupeGroupKey(jobsGroup, appKey)] = app
		case "CronJob":
			appKey, app, ok := mapCronJobToAppsCronJobs(doc)
			if !ok {
				rawFallbackDocs = append(rawFallbackDocs, doc)
				continue
			}
			cronjobsGroup[dedupeGroupKey(cronjobsGroup, appKey)] = app
		case "PodDisruptionBudget":
			pendingPDB = append(pendingPDB, doc)
		case "ServiceAccount":
			pendingSA = append(pendingSA, doc)
		case "Role":
			pendingRoles = append(pendingRoles, doc)
		case "RoleBinding":
			pendingRoleBindings = append(pendingRoleBindings, doc)
		case "ClusterRole":
			pendingClusterRoles = append(pendingClusterRoles, doc)
		case "ClusterRoleBinding":
			pendingClusterRoleBindings = append(pendingClusterRoleBindings, doc)
		default:
			rawFallbackDocs = append(rawFallbackDocs, doc)
		}
	}

	attachPDBsToStatelessApps(statelessByName, pendingPDB, &rawFallbackDocs)
	mapServiceAccountsToGroup(pendingSA, serviceAccountsGroup, serviceAccountsByNSName, &rawFallbackDocs)
	attachRBACToServiceAccounts(serviceAccountsByNSName, pendingRoles, pendingRoleBindings, pendingClusterRoles, pendingClusterRoleBindings, &rawFallbackDocs)
	// Attach inline serviceAccount to apps-stateless only as a compatibility fallback when
	// the ServiceAccount could not be represented in apps-service-accounts.
	attachServiceAccountsToStatelessApps(statelessByName, serviceAccountsByNSName, pendingSA, &rawFallbackDocs)

	if len(statelessGroup) > 0 {
		values["apps-stateless"] = statelessGroup
	}
	if len(configmapsGroup) > 0 {
		values["apps-configmaps"] = configmapsGroup
	}
	if len(secretsGroup) > 0 {
		values["apps-secrets"] = secretsGroup
	}
	if len(servicesGroup) > 0 {
		values["apps-services"] = servicesGroup
	}
	if len(ingressesGroup) > 0 {
		values["apps-ingresses"] = ingressesGroup
	}
	if len(netpolGroup) > 0 {
		values["apps-network-policies"] = netpolGroup
	}
	if len(serviceAccountsGroup) > 0 {
		values["apps-service-accounts"] = serviceAccountsGroup
	}
	if len(jobsGroup) > 0 {
		values["apps-jobs"] = jobsGroup
	}
	if len(cronjobsGroup) > 0 {
		values["apps-cronjobs"] = cronjobsGroup
	}

	if len(rawFallbackDocs) > 0 {
		rawValues, err := BuildValues(config.Config{
			Env:             cfg.Env,
			GroupName:       cfg.GroupName,
			GroupType:       cfg.GroupType,
			MinIncludeBytes: cfg.MinIncludeBytes,
			IncludeStatus:   cfg.IncludeStatus,
			ImportStrategy:  config.ImportStrategyRaw,
		}, rawFallbackDocs)
		if err != nil {
			return nil, err
		}
		mergeTopLevelValues(values, rawValues)
	}

	if len(values) == 1 { // only global
		return nil, fmt.Errorf("no supported Kubernetes resources found in input")
	}

	return values, nil
}

func kindOf(doc map[string]any) string {
	k, _ := doc["kind"].(string)
	return k
}

func mapConfigMapToAppsConfigmaps(doc map[string]any) (string, map[string]any, bool) {
	if !builtinNamespaceAllowed(metadataNamespace(doc)) {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")

	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	app := map[string]any{
		"enabled": true,
		"name":    name,
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	if s := yamlBody(doc["data"]); s != nil {
		app["data"] = *s
	}
	if s := yamlBody(doc["binaryData"]); s != nil {
		app["binaryData"] = *s
	}
	if v, ok := doc["immutable"]; ok {
		extra := map[string]any{"immutable": v}
		if s := yamlBody(cleanAny(extra)); s != nil {
			app["extraFields"] = *s
		}
	}
	if s := yamlBody(cleanAny(extractByAllowed(doc, "apiVersion", "kind", "metadata", "data", "binaryData", "immutable"))); s != nil {
		if prev, ok := app["extraFields"].(string); ok && strings.TrimSpace(prev) != "" {
			app["extraFields"] = strings.TrimSpace(prev) + "\n" + *s
		} else {
			app["extraFields"] = *s
		}
	}
	return sanitizeKey(name), app, true
}

func mapSecretToAppsSecrets(doc map[string]any) (string, map[string]any, bool) {
	if !builtinNamespaceAllowed(metadataNamespace(doc)) {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	app := map[string]any{
		"enabled": true,
		"name":    name,
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	if typ, ok := doc["type"]; ok && typ != nil {
		app["type"] = typ
	}
	if s := yamlBody(doc["data"]); s != nil {
		app["data"] = *s
	}
	if s := yamlBody(doc["stringData"]); s != nil {
		// Library native apps-secrets emits data:, so preserve stringData as raw top-level field.
		if prev, ok := app["extraFields"].(string); ok && strings.TrimSpace(prev) != "" {
			app["extraFields"] = strings.TrimSpace(prev) + "\nstringData:\n" + indentYAMLBlock(*s, 2)
		} else {
			app["extraFields"] = "stringData:\n" + indentYAMLBlock(*s, 2)
		}
	}
	if v, ok := doc["immutable"]; ok {
		extra := map[string]any{"immutable": v}
		if s := yamlBody(cleanAny(extra)); s != nil {
			if prev, ok := app["extraFields"].(string); ok && strings.TrimSpace(prev) != "" {
				app["extraFields"] = strings.TrimSpace(prev) + "\n" + *s
			} else {
				app["extraFields"] = *s
			}
		}
	}
	if s := yamlBody(cleanAny(extractByAllowed(doc, "apiVersion", "kind", "metadata", "type", "data", "stringData", "immutable"))); s != nil {
		if prev, ok := app["extraFields"].(string); ok && strings.TrimSpace(prev) != "" {
			app["extraFields"] = strings.TrimSpace(prev) + "\n" + *s
		} else {
			app["extraFields"] = *s
		}
	}
	return sanitizeKey(name), app, true
}

func mapDeploymentToAppsStateless(doc map[string]any) (string, map[string]any, bool) {
	if kindOf(doc) != "Deployment" {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	spec := getMap(doc, "spec")
	tpl := getMap(spec, "template")
	podSpec := getMap(tpl, "spec")
	containers, _ := podSpec["containers"].([]any)
	if len(containers) == 0 {
		return "", nil, false
	}

	app := map[string]any{
		"enabled": true,
		"name":    name,
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	if v, ok := spec["replicas"]; ok && v != nil {
		app["replicas"] = v
	}
	if v, ok := spec["revisionHistoryLimit"]; ok && v != nil {
		app["revisionHistoryLimit"] = v
	}
	if s := yamlBody(cleanAny(spec["strategy"])); s != nil {
		app["strategy"] = *s
	}
	if sel := mapAny(spec["selector"]); len(sel) > 0 {
		// apps-stateless.selector is rendered as matchLabels body, so store only matchLabels when possible.
		if ml := mapAny(sel["matchLabels"]); len(ml) > 0 {
			if s := yamlBody(cleanAny(ml)); s != nil {
				app["selector"] = *s
			}
		} else if s := yamlBody(cleanAny(sel)); s != nil {
			// Fallback: preserve whatever selector shape we got (may still be less ideal than matchLabels-only).
			app["selector"] = *s
		}
	} else if s := yamlBody(cleanAny(spec["selector"])); s != nil {
		app["selector"] = *s
	}

	if m, ok := mapContainersForStateless(containers); ok && len(m) > 0 {
		app["containers"] = m
	} else {
		return "", nil, false
	}
	if initContainers, _ := podSpec["initContainers"].([]any); len(initContainers) > 0 {
		if m, ok := mapContainersForStateless(initContainers); ok && len(m) > 0 {
			app["initContainers"] = m
		}
	}

	// Pod spec fields supported by apps-stateless.
	copyScalarIfPresent(app, podSpec, "automountServiceAccountToken")
	copyScalarIfPresent(app, podSpec, "hostIPC")
	copyScalarIfPresent(app, podSpec, "hostNetwork")
	copyScalarIfPresent(app, podSpec, "shareProcessNamespace")
	copyScalarIfPresent(app, podSpec, "dnsPolicy")
	copyScalarIfPresent(app, podSpec, "priorityClassName")
	copyScalarIfPresent(app, podSpec, "serviceAccountName")
	copyScalarIfPresent(app, podSpec, "terminationGracePeriodSeconds")
	for _, key := range []string{"affinity", "tolerations", "volumes", "securityContext", "imagePullSecrets", "nodeSelector", "topologySpreadConstraints"} {
		if s := yamlBody(cleanAny(podSpec[key])); s != nil {
			app[key] = *s
		}
	}

	if s := yamlBody(cleanAny(extractDeploymentExtraSpec(spec))); s != nil {
		app["extraSpec"] = *s
	}

	return sanitizeKey(name), app, true
}

func mapServiceToAppsServices(doc map[string]any) (string, map[string]any, bool) {
	if kindOf(doc) != "Service" {
		return "", nil, false
	}
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")
	spec := getMap(doc, "spec")
	app := map[string]any{"enabled": true, "name": name}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	for _, key := range []string{"ports", "selector", "sessionAffinityConfig"} {
		if s := yamlBody(cleanAny(spec[key])); s != nil {
			app[key] = *s
		}
	}
	for _, key := range []string{
		"type", "clusterIP", "externalName", "externalTrafficPolicy", "internalTrafficPolicy", "ipFamilyPolicy",
		"loadBalancerClass", "loadBalancerIP", "sessionAffinity",
	} {
		copyScalarIfPresent(app, spec, key)
	}
	for _, key := range []string{"publishNotReadyAddresses", "allocateLoadBalancerNodePorts"} {
		copyScalarIfPresent(app, spec, key)
	}
	for _, key := range []string{"healthCheckNodePort"} {
		copyScalarIfPresent(app, spec, key)
	}
	for _, key := range []string{"clusterIPs", "externalIPs", "ipFamilies", "loadBalancerSourceRanges"} {
		if s := yamlBody(cleanAny(spec[key])); s != nil {
			app[key] = *s
		}
	}
	if s := yamlBody(cleanAny(extractServiceExtraSpec(spec))); s != nil {
		app["extraSpec"] = *s
	}
	return sanitizeKey(name), app, true
}

func mapIngressToAppsIngresses(doc map[string]any) (string, map[string]any, bool) {
	if kindOf(doc) != "Ingress" {
		return "", nil, false
	}
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")
	spec := getMap(doc, "spec")
	rules, _ := spec["rules"].([]any)
	if len(rules) != 1 {
		return "", nil, false
	}
	rule := mapAny(rules[0])
	host, _ := rule["host"].(string)
	httpBlock := mapAny(rule["http"])
	paths := httpBlock["paths"]
	if paths == nil {
		return "", nil, false
	}

	app := map[string]any{
		"enabled": true,
		"name":    name,
		"host":    host,
	}
	ann := mapStringAny(mapAny(metadata["annotations"]))
	if cls, ok := ann["kubernetes.io/ingress.class"]; ok && cls != nil {
		if s, _ := cls.(string); strings.TrimSpace(s) != "" {
			app["class"] = strings.TrimSpace(s)
		}
		delete(ann, "kubernetes.io/ingress.class")
	}
	if s := yamlBody(ann); s != nil {
		app["annotations"] = *s
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(cleanAny(paths)); s != nil {
		app["paths"] = *s
	}
	if v, ok := spec["ingressClassName"]; ok && v != nil {
		app["ingressClassName"] = v
	}
	if tls, _ := spec["tls"].([]any); len(tls) > 0 {
		tls0 := mapAny(tls[0])
		tlsMap := map[string]any{"enabled": true}
		if secretName, _ := tls0["secretName"].(string); strings.TrimSpace(secretName) != "" {
			tlsMap["secret_name"] = secretName
		}
		app["tls"] = tlsMap
	}
	if s := yamlBody(cleanAny(extractIngressExtraSpec(spec))); s != nil {
		app["extraSpec"] = *s
	}
	return sanitizeKey(name), app, true
}

func mapNetworkPolicyToAppsNetworkPolicies(doc map[string]any) (string, map[string]any, bool) {
	if kindOf(doc) != "NetworkPolicy" {
		return "", nil, false
	}
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")
	spec := getMap(doc, "spec")
	app := map[string]any{
		"enabled": true,
		"name":    name,
		"type":    "kubernetes",
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	for _, key := range []string{"podSelector", "policyTypes", "ingress", "egress"} {
		if s := yamlBody(cleanAny(spec[key])); s != nil {
			app[key] = *s
		}
	}
	if s := yamlBody(cleanAny(extractByAllowed(spec, "podSelector", "policyTypes", "ingress", "egress"))); s != nil {
		app["spec"] = *s
	}
	return sanitizeKey(name), app, true
}

func mapJobToAppsJobs(doc map[string]any) (string, map[string]any, bool) {
	if kindOf(doc) != "Job" {
		return "", nil, false
	}
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")
	spec := getMap(doc, "spec")
	tpl := getMap(spec, "template")
	podSpec := getMap(tpl, "spec")
	containers, _ := podSpec["containers"].([]any)
	if len(containers) == 0 {
		return "", nil, false
	}
	app := map[string]any{
		"enabled": true,
		"name":    name,
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	if m, ok := mapContainersForStateless(containers); ok && len(m) > 0 {
		app["containers"] = m
	} else {
		return "", nil, false
	}
	if initContainers, _ := podSpec["initContainers"].([]any); len(initContainers) > 0 {
		if m, ok := mapContainersForStateless(initContainers); ok && len(m) > 0 {
			app["initContainers"] = m
		}
	}
	mergeMaps(app, mapPodSpecFieldsForLibrary(podSpec))
	// Job top-level spec keys handled by apps-helpers.jobTemplate.
	for _, key := range []string{"parallelism", "completions", "backoffLimit", "activeDeadlineSeconds", "ttlSecondsAfterFinished"} {
		copyScalarIfPresent(app, spec, key)
	}
	for _, key := range []string{"manualSelector", "suspend"} {
		copyScalarIfPresent(app, spec, key)
	}
	if s := yamlBody(cleanAny(spec["selector"])); s != nil {
		app["selector"] = *s
	}
	copyScalarIfPresent(app, spec, "completionMode")
	if s := yamlBody(cleanAny(extractByAllowed(spec,
		"parallelism", "completions", "backoffLimit", "activeDeadlineSeconds", "ttlSecondsAfterFinished",
		"manualSelector", "suspend", "selector", "completionMode", "template",
	))); s != nil {
		app["jobTemplateExtraSpec"] = *s
	}
	return sanitizeKey(name), app, true
}

func mapCronJobToAppsCronJobs(doc map[string]any) (string, map[string]any, bool) {
	if kindOf(doc) != "CronJob" {
		return "", nil, false
	}
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	metadata := getMap(doc, "metadata")
	spec := getMap(doc, "spec")
	jobTemplate := getMap(spec, "jobTemplate")
	jobSpec := getMap(jobTemplate, "spec")
	tpl := getMap(jobSpec, "template")
	podSpec := getMap(tpl, "spec")
	containers, _ := podSpec["containers"].([]any)
	if len(containers) == 0 {
		return "", nil, false
	}

	app := map[string]any{
		"enabled": true,
		"name":    name,
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	if m, ok := mapContainersForStateless(containers); ok && len(m) > 0 {
		app["containers"] = m
	} else {
		return "", nil, false
	}
	if initContainers, _ := podSpec["initContainers"].([]any); len(initContainers) > 0 {
		if m, ok := mapContainersForStateless(initContainers); ok && len(m) > 0 {
			app["initContainers"] = m
		}
	}
	mergeMaps(app, mapPodSpecFieldsForLibrary(podSpec))
	// CronJob-specific keys
	for _, key := range []string{"schedule", "concurrencyPolicy"} {
		copyScalarIfPresent(app, spec, key)
	}
	for _, key := range []string{"failedJobsHistoryLimit", "startingDeadlineSeconds", "successfulJobsHistoryLimit"} {
		copyScalarIfPresent(app, spec, key)
	}
	copyScalarIfPresent(app, spec, "suspend")
	// Job template keys inside CronJob are rendered by apps-helpers.jobTemplate.
	for _, key := range []string{"parallelism", "completions", "backoffLimit", "activeDeadlineSeconds", "ttlSecondsAfterFinished"} {
		copyScalarIfPresent(app, jobSpec, key)
	}
	for _, key := range []string{"manualSelector"} {
		copyScalarIfPresent(app, jobSpec, key)
	}
	if s := yamlBody(cleanAny(jobSpec["selector"])); s != nil {
		app["selector"] = *s
	}
	copyScalarIfPresent(app, jobSpec, "completionMode")
	if s := yamlBody(cleanAny(extractByAllowed(jobSpec,
		"parallelism", "completions", "backoffLimit", "activeDeadlineSeconds", "ttlSecondsAfterFinished",
		"manualSelector", "selector", "completionMode", "template",
	))); s != nil {
		app["jobTemplateExtraSpec"] = *s
	}
	if s := yamlBody(cleanAny(extractByAllowed(spec,
		"schedule", "concurrencyPolicy", "failedJobsHistoryLimit", "startingDeadlineSeconds",
		"successfulJobsHistoryLimit", "suspend", "jobTemplate",
	))); s != nil {
		app["extraSpec"] = *s
	}
	return sanitizeKey(name), app, true
}

func mapPodSpecFieldsForLibrary(podSpec map[string]any) map[string]any {
	out := map[string]any{}
	copyScalarIfPresent(out, podSpec, "automountServiceAccountToken")
	copyScalarIfPresent(out, podSpec, "hostIPC")
	copyScalarIfPresent(out, podSpec, "hostNetwork")
	copyScalarIfPresent(out, podSpec, "shareProcessNamespace")
	copyScalarIfPresent(out, podSpec, "dnsPolicy")
	copyScalarIfPresent(out, podSpec, "priorityClassName")
	copyScalarIfPresent(out, podSpec, "serviceAccountName")
	copyScalarIfPresent(out, podSpec, "serviceAccount")
	copyScalarIfPresent(out, podSpec, "terminationGracePeriodSeconds")
	copyScalarIfPresent(out, podSpec, "restartPolicy")
	for _, key := range []string{"affinity", "tolerations", "volumes", "securityContext", "imagePullSecrets", "nodeSelector", "topologySpreadConstraints", "hostAliases", "dnsConfig", "readinessGates", "overhead"} {
		if s := yamlBody(cleanAny(podSpec[key])); s != nil {
			out[key] = *s
		}
	}
	if s := yamlBody(cleanAny(extractByAllowed(podSpec,
		"containers", "initContainers",
		"automountServiceAccountToken", "hostIPC", "hostNetwork", "shareProcessNamespace",
		"dnsPolicy", "priorityClassName", "serviceAccountName", "serviceAccount",
		"terminationGracePeriodSeconds", "restartPolicy",
		"affinity", "tolerations", "volumes", "securityContext", "imagePullSecrets",
		"nodeSelector", "topologySpreadConstraints", "hostAliases", "dnsConfig", "readinessGates", "overhead",
	))); s != nil {
		out["podSpecExtra"] = *s
	}
	return out
}

func mergeMaps(dst, src map[string]any) {
	for k, v := range src {
		dst[k] = v
	}
}

func attachPDBsToStatelessApps(statelessByName map[string]map[string]any, docs []map[string]any, rawFallback *[]map[string]any) {
	for _, doc := range docs {
		name := metadataName(doc)
		ns := metadataNamespace(doc)
		app := statelessByName[ns+"/"+name]
		if app == nil {
			*rawFallback = append(*rawFallback, doc)
			continue
		}
		spec := getMap(doc, "spec")
		pdb := map[string]any{"enabled": true}
		if v, ok := spec["maxUnavailable"]; ok && v != nil {
			pdb["maxUnavailable"] = v
		}
		if v, ok := spec["minAvailable"]; ok && v != nil {
			pdb["minAvailable"] = v
		}
		if s := yamlBody(cleanAny(extractByAllowed(spec, "selector", "maxUnavailable", "minAvailable"))); s != nil {
			pdb["extraSpec"] = *s
		}
		app["podDisruptionBudget"] = pdb
	}
}

func attachServiceAccountsToStatelessApps(statelessByName map[string]map[string]any, serviceAccountsByNSName map[string]map[string]any, docs []map[string]any, rawFallback *[]map[string]any) {
	for _, doc := range docs {
		name := metadataName(doc)
		ns := metadataNamespace(doc)
		if serviceAccountsByNSName[normalizedNS(ns)+"/"+name] != nil {
			// Already rendered natively via apps-service-accounts; avoid duplicate ServiceAccount.
			continue
		}
		app := statelessByName[ns+"/"+name]
		if app == nil {
			*rawFallback = append(*rawFallback, doc)
			continue
		}
		metadata := getMap(doc, "metadata")
		sa := map[string]any{"enabled": true, "name": name}
		if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
			sa["labels"] = *s
		}
		if s := yamlBody(metadata["annotations"]); s != nil {
			sa["annotations"] = *s
		}
		app["serviceAccount"] = sa
	}
}

func mapServiceAccountsToGroup(docs []map[string]any, group map[string]any, byNSName map[string]map[string]any, rawFallback *[]map[string]any) {
	for _, doc := range docs {
		appKey, app, ok := mapServiceAccountToAppsServiceAccounts(doc)
		if !ok {
			*rawFallback = append(*rawFallback, doc)
			continue
		}
		key := dedupeGroupKey(group, appKey)
		group[key] = app
		name := metadataName(doc)
		ns := metadataNamespace(doc)
		if strings.TrimSpace(name) != "" {
			byNSName[normalizedNS(ns)+"/"+name] = app
		}
	}
}

func mapServiceAccountToAppsServiceAccounts(doc map[string]any) (string, map[string]any, bool) {
	if kindOf(doc) != "ServiceAccount" {
		return "", nil, false
	}
	name := metadataName(doc)
	if name == "" {
		return "", nil, false
	}
	ns := metadataNamespace(doc)
	metadata := getMap(doc, "metadata")
	app := map[string]any{
		"enabled": true,
		"name":    name,
	}
	if strings.TrimSpace(ns) != "" && ns != "default" {
		app["namespace"] = ns
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		app["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		app["annotations"] = *s
	}
	copyScalarIfPresent(app, doc, "automountServiceAccountToken")
	if s := yamlBody(cleanAny(doc["imagePullSecrets"])); s != nil {
		app["imagePullSecrets"] = *s
	}
	// SA "secrets" field isn't first-class in values contract, preserve via extraFields.
	if s := yamlBody(cleanAny(extractByAllowed(doc,
		"apiVersion", "kind", "metadata", "automountServiceAccountToken", "imagePullSecrets",
	))); s != nil {
		app["extraFields"] = *s
	}
	return sanitizeKey(name), app, true
}

func attachRBACToServiceAccounts(
	serviceAccountsByNSName map[string]map[string]any,
	roles, roleBindings, clusterRoles, clusterRoleBindings []map[string]any,
	rawFallback *[]map[string]any,
) {
	roleByNSName := map[string]map[string]any{}
	clusterRoleByName := map[string]map[string]any{}
	for _, doc := range roles {
		roleByNSName[metadataNamespace(doc)+"/"+metadataName(doc)] = doc
	}
	for _, doc := range clusterRoles {
		clusterRoleByName[metadataName(doc)] = doc
	}
	for _, rb := range roleBindings {
		saNS, saName, ok := roleBindingTargetServiceAccount(rb)
		if !ok {
			*rawFallback = append(*rawFallback, rb)
			continue
		}
		saApp := serviceAccountsByNSName[saNS+"/"+saName]
		if saApp == nil {
			*rawFallback = append(*rawFallback, rb)
			continue
		}
		roleRef := mapAny(getMap(rb, "roleRef"))
		if strings.TrimSpace(asString(roleRef["apiGroup"])) != "rbac.authorization.k8s.io" || strings.TrimSpace(asString(roleRef["kind"])) != "Role" {
			*rawFallback = append(*rawFallback, rb)
			continue
		}
		roleName := strings.TrimSpace(asString(roleRef["name"]))
		roleDoc := roleByNSName[metadataNamespace(rb)+"/"+roleName]
		if roleDoc == nil {
			*rawFallback = append(*rawFallback, rb)
			continue
		}
		if !attachRoleDocToServiceAccount(saApp, roleDoc, rb, metadataName(roleDoc), "Role") {
			*rawFallback = append(*rawFallback, rb, roleDoc)
			continue
		}
		markRBAttached(rb)
	}

	for _, crb := range clusterRoleBindings {
		saNS, saName, ok := roleBindingTargetServiceAccount(crb)
		if !ok {
			*rawFallback = append(*rawFallback, crb)
			continue
		}
		saApp := serviceAccountsByNSName[saNS+"/"+saName]
		if saApp == nil {
			*rawFallback = append(*rawFallback, crb)
			continue
		}
		roleRef := mapAny(getMap(crb, "roleRef"))
		if strings.TrimSpace(asString(roleRef["apiGroup"])) != "rbac.authorization.k8s.io" || strings.TrimSpace(asString(roleRef["kind"])) != "ClusterRole" {
			*rawFallback = append(*rawFallback, crb)
			continue
		}
		roleName := strings.TrimSpace(asString(roleRef["name"]))
		crDoc := clusterRoleByName[roleName]
		if crDoc == nil {
			*rawFallback = append(*rawFallback, crb)
			continue
		}
		if !attachClusterRoleDocToServiceAccount(saApp, crDoc, crb, metadataName(crDoc), "ClusterRole") {
			*rawFallback = append(*rawFallback, crb, crDoc)
			continue
		}
		markRBAttached(crb)
	}

	// Any RBAC docs not attached go to generic fallback.
	for _, d := range roles {
		if !rbAttached(d) {
			*rawFallback = append(*rawFallback, d)
		}
	}
	for _, d := range roleBindings {
		// Bound rolebindings are already not tracked; dedupe later is hard, but safe to skip if attached by matching role key exists.
		// We mark by structural attach via annotation in helper field.
		if rbAttached(d) {
			continue
		}
		*rawFallback = append(*rawFallback, d)
	}
	for _, d := range clusterRoles {
		if !rbAttached(d) {
			*rawFallback = append(*rawFallback, d)
		}
	}
	for _, d := range clusterRoleBindings {
		if rbAttached(d) {
			continue
		}
		*rawFallback = append(*rawFallback, d)
	}
}

func roleBindingTargetServiceAccount(doc map[string]any) (namespace, name string, ok bool) {
	subjects, _ := doc["subjects"].([]any)
	if len(subjects) == 0 {
		return "", "", false
	}
	seen := map[string]struct{}{}
	for _, subj := range subjects {
		s := mapAny(subj)
		kind := strings.TrimSpace(asString(s["kind"]))
		if kind == "" {
			return "", "", false
		}
		if kind != "ServiceAccount" {
			continue
		}
		saName := strings.TrimSpace(asString(s["name"]))
		if saName == "" {
			return "", "", false
		}
		saNS := strings.TrimSpace(asString(s["namespace"]))
		if saNS == "" {
			saNS = metadataNamespace(doc)
		}
		saNS = normalizedNS(saNS)
		key := saNS + "/" + saName
		seen[key] = struct{}{}
	}
	if len(seen) != 1 {
		// We can attach only when exactly one distinct target service account is present.
		return "", "", false
	}
	for k := range seen {
		parts := strings.SplitN(k, "/", 2)
		if len(parts) == 2 {
			return parts[0], parts[1], true
		}
	}
	return "", "", false
}

func normalizedNS(ns string) string {
	if strings.TrimSpace(ns) == "" {
		return "default"
	}
	return strings.TrimSpace(ns)
}

func attachRoleDocToServiceAccount(saApp map[string]any, roleDoc, bindingDoc map[string]any, roleKey, roleKind string) bool {
	roleApp, ok := mapRoleDocToServiceAccountRole(roleDoc)
	if !ok {
		return false
	}
	if b, ok := mapRoleBindingOverride(bindingDoc, roleDoc, roleKind); ok {
		roleApp["binding"] = b
	}
	rolesMap, _ := saApp["roles"].(map[string]any)
	if rolesMap == nil {
		rolesMap = map[string]any{}
		saApp["roles"] = rolesMap
	}
	rolesMap[dedupeGroupKey(rolesMap, sanitizeKey(roleKey))] = roleApp
	markRBAttached(roleDoc)
	return true
}

func attachClusterRoleDocToServiceAccount(saApp map[string]any, roleDoc, bindingDoc map[string]any, roleKey, roleKind string) bool {
	roleApp, ok := mapRoleDocToServiceAccountRole(roleDoc)
	if !ok {
		return false
	}
	if b, ok := mapRoleBindingOverride(bindingDoc, roleDoc, roleKind); ok {
		roleApp["binding"] = b
	}
	rolesMap, _ := saApp["clusterRoles"].(map[string]any)
	if rolesMap == nil {
		rolesMap = map[string]any{}
		saApp["clusterRoles"] = rolesMap
	}
	rolesMap[dedupeGroupKey(rolesMap, sanitizeKey(roleKey))] = roleApp
	markRBAttached(roleDoc)
	return true
}

func mapRoleDocToServiceAccountRole(doc map[string]any) (map[string]any, bool) {
	specRules, _ := doc["rules"].([]any)
	role := map[string]any{}
	metadata := getMap(doc, "metadata")
	if len(specRules) == 0 {
		return nil, false
	}
	if name := metadataName(doc); strings.TrimSpace(name) != "" {
		role["name"] = name
	}
	if s := yamlBody(filterImportedMetadataLabels(metadata["labels"])); s != nil {
		role["labels"] = *s
	}
	if s := yamlBody(metadata["annotations"]); s != nil {
		role["annotations"] = *s
	}
	rulesMap := map[string]any{}
	ruleKeyWidth := len(strconv.Itoa(len(specRules)))
	if ruleKeyWidth < 1 {
		ruleKeyWidth = 1
	}
	for i, r := range specRules {
		rm := mapAny(r)
		if len(rm) == 0 {
			continue
		}
		item := map[string]any{}
		for _, k := range []string{"apiGroups", "resources", "verbs", "resourceNames", "nonResourceURLs"} {
			if v, ok := rm[k]; ok && v != nil {
				item[k] = cleanAny(v)
			}
		}
		if s := yamlBody(cleanAny(extractByAllowed(rm, "apiGroups", "resources", "verbs", "resourceNames", "nonResourceURLs"))); s != nil {
			item["extraFields"] = *s
		}
		if len(item) == 0 {
			continue
		}
		if ruleKeyWidth > 1 {
			rulesMap[fmt.Sprintf("rule-%0*d", ruleKeyWidth, i+1)] = item
		} else {
			rulesMap[fmt.Sprintf("rule-%d", i+1)] = item
		}
	}
	if len(rulesMap) == 0 {
		return nil, false
	}
	role["rules"] = rulesMap
	if s := yamlBody(cleanAny(extractByAllowed(doc, "apiVersion", "kind", "metadata", "rules"))); s != nil {
		role["extraFields"] = *s
	}
	return role, true
}

func mapRoleBindingOverride(bindingDoc, roleDoc map[string]any, roleKind string) (map[string]any, bool) {
	if bindingDoc == nil {
		return nil, false
	}
	roleRef := mapAny(getMap(bindingDoc, "roleRef"))
	if strings.TrimSpace(asString(roleRef["apiGroup"])) != "rbac.authorization.k8s.io" {
		return nil, false
	}
	if strings.TrimSpace(asString(roleRef["kind"])) != strings.TrimSpace(roleKind) {
		return nil, false
	}
	if strings.TrimSpace(asString(roleRef["name"])) != strings.TrimSpace(metadataName(roleDoc)) {
		// If roleRef name doesn't match the attached role object name, we can't preserve semantics.
		return nil, false
	}
	override := map[string]any{}
	if bn := metadataName(bindingDoc); bn != "" && bn != metadataName(roleDoc) {
		override["name"] = bn
	}
	bm := getMap(bindingDoc, "metadata")
	if s := yamlBody(filterImportedMetadataLabels(bm["labels"])); s != nil {
		override["labels"] = *s
	}
	if s := yamlBody(bm["annotations"]); s != nil {
		override["annotations"] = *s
	}
	if ns := metadataNamespace(bindingDoc); ns != "" && ns != "default" {
		override["namespace"] = ns
	}
	if !isDefaultSingleServiceAccountBindingSubjects(bindingDoc) {
		if s := yamlBody(cleanAny(bindingDoc["subjects"])); s != nil {
			override["subjects"] = *s
		}
	}
	if s := yamlBody(cleanAny(extractByAllowed(bindingDoc, "apiVersion", "kind", "metadata", "subjects", "roleRef"))); s != nil {
		override["extraFields"] = *s
	}
	if len(override) == 0 {
		return nil, false
	}
	return override, true
}

func isDefaultSingleServiceAccountBindingSubjects(bindingDoc map[string]any) bool {
	subjects, _ := bindingDoc["subjects"].([]any)
	if len(subjects) != 1 {
		return false
	}
	s := mapAny(subjects[0])
	if strings.TrimSpace(asString(s["kind"])) != "ServiceAccount" {
		return false
	}
	if strings.TrimSpace(asString(s["name"])) == "" {
		return false
	}
	ns := normalizedNS(asString(s["namespace"]))
	return ns == normalizedNS(metadataNamespace(bindingDoc))
}

func markRBAttached(doc map[string]any) {
	doc["__importerRBACAttached"] = true
}

func rbAttached(doc map[string]any) bool {
	v, _ := doc["__importerRBACAttached"].(bool)
	return v
}

func asString(v any) string {
	s, _ := v.(string)
	return s
}

func mapContainersForStateless(in []any) (map[string]any, bool) {
	out := map[string]any{}
	for i, raw := range in {
		c := mapAny(raw)
		name, _ := c["name"].(string)
		if strings.TrimSpace(name) == "" {
			name = fmt.Sprintf("container-%d", i+1)
		}
		mapped, ok := mapContainerForStateless(c)
		if !ok {
			return nil, false
		}
		out[sanitizeKey(name)] = mapped
	}
	return out, len(out) > 0
}

func mapContainerForStateless(c map[string]any) (map[string]any, bool) {
	image, ok := parseContainerImage(c["image"])
	if !ok {
		return nil, false
	}
	out := map[string]any{
		"image": image,
	}
	copyScalarIfPresent(out, c, "imagePullPolicy")
	for _, key := range []string{"ports", "command", "args", "volumeMounts"} {
		if s := yamlBody(cleanAny(c[key])); s != nil {
			out[key] = *s
		}
	}
	envVars, envResidual := splitContainerEnv(c["env"])
	if len(envVars) > 0 {
		out["envVars"] = envVars
	}
	if s := yamlBody(cleanAny(envResidual)); s != nil {
		out["env"] = *s
	}
	sharedCMs, sharedSecrets, envFromResidual := splitContainerEnvFrom(c["envFrom"])
	if len(sharedCMs) > 0 {
		out["sharedEnvConfigMaps"] = stringSliceToAny(sharedCMs)
	}
	if len(sharedSecrets) > 0 {
		out["sharedEnvSecrets"] = stringSliceToAny(sharedSecrets)
	}
	if s := yamlBody(cleanAny(envFromResidual)); s != nil {
		out["envFrom"] = *s
	}
	for _, key := range []string{"livenessProbe", "readinessProbe", "startupProbe", "securityContext", "lifecycle"} {
		if s := yamlBody(cleanAny(c[key])); s != nil {
			out[key] = *s
		}
	}
	// resources helper expects library-specific structure; preserve raw in extraFields.
	if s := yamlBody(cleanAny(extractContainerExtraFields(c))); s != nil {
		out["extraFields"] = *s
	}
	return out, true
}

func parseContainerImage(v any) (map[string]any, bool) {
	s, _ := v.(string)
	s = strings.TrimSpace(s)
	if s == "" {
		return nil, false
	}
	lastSlash := strings.LastIndex(s, "/")
	lastColon := strings.LastIndex(s, ":")
	if lastColon <= lastSlash {
		return map[string]any{
			"name":      s,
			"staticTag": "latest",
		}, true
	}
	return map[string]any{
		"name":      s[:lastColon],
		"staticTag": s[lastColon+1:],
	}, true
}

func splitContainerEnv(v any) (map[string]any, []any) {
	items, _ := v.([]any)
	if len(items) == 0 {
		return nil, nil
	}
	envVars := map[string]any{}
	var residual []any
	for _, it := range items {
		m := mapAny(it)
		name, _ := m["name"].(string)
		name = strings.TrimSpace(name)
		if name == "" {
			residual = append(residual, cleanAny(it))
			continue
		}
		if _, hasValueFrom := m["valueFrom"]; !hasValueFrom {
			if val, ok := m["value"]; ok && val != nil {
				envVars[name] = val
				continue
			}
		}
		residual = append(residual, cleanAny(it))
	}
	if len(envVars) == 0 {
		envVars = nil
	}
	return envVars, residual
}

func splitContainerEnvFrom(v any) (sharedCMs []string, sharedSecrets []string, residual []any) {
	items, _ := v.([]any)
	for _, it := range items {
		m := mapAny(it)
		if len(m) == 0 {
			continue
		}
		if cmRef := mapAny(m["configMapRef"]); len(cmRef) > 0 {
			name, _ := cmRef["name"].(string)
			optional, hasOptional := cmRef["optional"]
			if strings.TrimSpace(name) != "" && (!hasOptional || optional == nil) && len(m) == 1 {
				sharedCMs = append(sharedCMs, strings.TrimSpace(name))
				continue
			}
		}
		if secRef := mapAny(m["secretRef"]); len(secRef) > 0 {
			name, _ := secRef["name"].(string)
			optional, hasOptional := secRef["optional"]
			if strings.TrimSpace(name) != "" && (!hasOptional || optional == nil) && len(m) == 1 {
				sharedSecrets = append(sharedSecrets, strings.TrimSpace(name))
				continue
			}
		}
		residual = append(residual, cleanAny(it))
	}
	sharedCMs = uniqStrings(sharedCMs)
	sharedSecrets = uniqStrings(sharedSecrets)
	return sharedCMs, sharedSecrets, residual
}

func stringSliceToAny(in []string) []any {
	out := make([]any, 0, len(in))
	for _, s := range in {
		out = append(out, s)
	}
	return out
}

func copyScalarIfPresent(dst, src map[string]any, key string) {
	if v, ok := src[key]; ok && v != nil {
		dst[key] = v
	}
}

func extractDeploymentExtraSpec(spec map[string]any) map[string]any {
	return extractByAllowed(spec,
		"replicas", "revisionHistoryLimit", "strategy", "selector", "template",
	)
}

func extractServiceExtraSpec(spec map[string]any) map[string]any {
	return extractByAllowed(spec,
		"ports", "selector", "sessionAffinityConfig",
		"type", "clusterIP", "externalName", "externalTrafficPolicy", "internalTrafficPolicy",
		"ipFamilyPolicy", "loadBalancerClass", "loadBalancerIP", "sessionAffinity",
		"publishNotReadyAddresses", "allocateLoadBalancerNodePorts", "healthCheckNodePort",
		"clusterIPs", "externalIPs", "ipFamilies", "loadBalancerSourceRanges",
	)
}

func extractIngressExtraSpec(spec map[string]any) map[string]any {
	return extractByAllowed(spec, "ingressClassName", "rules", "tls")
}

func extractContainerExtraFields(c map[string]any) map[string]any {
	return extractByAllowed(c,
		"name", "image", "imagePullPolicy", "ports", "command", "args", "env", "envFrom",
		"livenessProbe", "readinessProbe", "startupProbe", "securityContext", "lifecycle",
		"volumeMounts",
	)
}

func extractByAllowed(src map[string]any, handled ...string) map[string]any {
	if len(src) == 0 {
		return nil
	}
	seen := map[string]struct{}{}
	for _, k := range handled {
		seen[k] = struct{}{}
	}
	out := map[string]any{}
	for _, k := range sortedKeys(src) {
		if _, ok := seen[k]; ok {
			continue
		}
		if v := cleanAny(src[k]); !isBlankContainer(v) {
			out[k] = v
		}
	}
	if len(out) == 0 {
		return nil
	}
	return out
}

func cleanAny(v any) any {
	switch x := v.(type) {
	case nil:
		return nil
	case map[string]any:
		out := map[string]any{}
		for _, k := range sortedKeys(x) {
			cv := cleanAny(x[k])
			if cv == nil {
				continue
			}
			out[k] = cv
		}
		if len(out) == 0 {
			return nil
		}
		return out
	case []any:
		out := make([]any, 0, len(x))
		for _, it := range x {
			cv := cleanAny(it)
			if cv == nil {
				continue
			}
			out = append(out, cv)
		}
		if len(out) == 0 {
			return nil
		}
		return out
	default:
		return x
	}
}
