name: Release Charts

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "$GITHUB_ACTOR"
          git config user.email "$GITHUB_ACTOR@users.noreply.github.com"

      - name: Set lib version
        run: |
          LIB_VERSION=$(sed -n '/version/{s/version: //;p;}' charts/helm-apps/Chart.yaml)
          echo "LIB_VERSION=${LIB_VERSION}" >> "$GITHUB_ENV"
          sed -i 's/_FLANT_APPS_LIBRARY_VERSION_/'${LIB_VERSION}'/' charts/helm-apps/templates/_apps-version.tpl

      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: v2.57.1

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.15.4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: cmd/happ/go.mod

      - name: Setup Node.js (for VS Code extension)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Setup golangci-lint (for happ)
        uses: golangci/golangci-lint-action@v6
        with:
          version: v1.64.8
          working-directory: cmd/happ
          install-mode: binary
          skip-cache: true
          skip-save-cache: true

      - name: Install Dyff
        run: |
          curl --silent --location https://git.io/JYfAY | bash

      - name: Install kubeconform
        run: |
          set -euo pipefail
          KUBECONFORM_VERSION=0.6.7
          curl -sSL -o /tmp/kubeconform.tar.gz "https://github.com/yannh/kubeconform/releases/download/v${KUBECONFORM_VERSION}/kubeconform-linux-amd64.tar.gz"
          tar -xzf /tmp/kubeconform.tar.gz -C /tmp kubeconform
          sudo install -m 0755 /tmp/kubeconform /usr/local/bin/kubeconform

      - name: Update test chart dependencies
        run: |
          helm dependency update tests/.helm

      - name: Validate values schema
        run: |
          helm lint tests/.helm --values tests/.helm/values.yaml

      - name: Verify Kubernetes API compatibility
        run: |
          set -euo pipefail

          # New clusters: stable APIs must be rendered.
          helm template tests tests/.helm \
            --set "global.env=prod" \
            --set "global._includes.apps-defaults.enabled=true" \
            --kube-version 1.29.0 > /tmp/tests_k8s_129.yaml
          grep -q '^apiVersion: policy/v1$' /tmp/tests_k8s_129.yaml
          grep -q '^apiVersion: batch/v1$' /tmp/tests_k8s_129.yaml
          grep -q '^apiVersion: autoscaling/v2$' /tmp/tests_k8s_129.yaml
          ! grep -q '^apiVersion: policy/v1beta1$' /tmp/tests_k8s_129.yaml
          ! grep -q '^apiVersion: batch/v1beta1$' /tmp/tests_k8s_129.yaml
          ! grep -q '^apiVersion: autoscaling/v2beta2$' /tmp/tests_k8s_129.yaml
          kubeconform -strict -summary -ignore-missing-schemas -kubernetes-version 1.29.0 /tmp/tests_k8s_129.yaml

          # Legacy clusters: beta APIs remain supported.
          helm template tests tests/.helm \
            --set "global.env=prod" \
            --set "global._includes.apps-defaults.enabled=true" \
            --kube-version 1.20.15 > /tmp/tests_k8s_120.yaml
          grep -q '^apiVersion: policy/v1beta1$' /tmp/tests_k8s_120.yaml
          grep -q '^apiVersion: batch/v1beta1$' /tmp/tests_k8s_120.yaml
          grep -q '^apiVersion: autoscaling/v2beta2$' /tmp/tests_k8s_120.yaml
          ! grep -q '^apiVersion: autoscaling/v2$' /tmp/tests_k8s_120.yaml
          kubeconform -strict -summary -ignore-missing-schemas -kubernetes-version 1.20.15 /tmp/tests_k8s_120.yaml

      - name: Render
        run: |
          set -e
          source $(werf ci-env github --as-file)
          cd tests && werf render --dev --set "global._includes.apps-defaults.enabled=true" --env=prod

      - name: Test render
        run: |
          set -e
          source $(werf ci-env github --as-file)
          ruby scripts/validate-yaml-stream.rb tests/test_render.yaml
          cd tests && werf render --dev --set "global._includes.apps-defaults.enabled=true" --env=prod | sed '/werf.io\//d' > test_render_check.yaml
          ruby ../scripts/validate-yaml-stream.rb test_render_check.yaml
          dyff between test_render.yaml test_render_check.yaml | tee /tmp/test_render_check
          check_tests=$(sed 1,7d /tmp/test_render_check | wc -l)
          if [ $check_tests -gt "7" ]; then exit 1; fi

      - name: Check apps entity coverage in contracts
        run: |
          set -euo pipefail
          bash scripts/check-entity-coverage.sh

      - name: Contract checks (snapshot + structural + negative)
        run: |
          set -euo pipefail
          bash scripts/check-contracts.sh

      - name: Test and lint happ
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          set -euo pipefail
          cd cmd/happ
          go generate ./assets
          golangci-lint run
          go test ./...

      - name: Build and test extension
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          set -euo pipefail
          cd extensions/helm-apps
          npm ci
          npm run build
          npm test

      - name: Package extension VSIX
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          set -euo pipefail
          cd extensions/helm-apps
          npx --yes @vscode/vsce package --no-dependencies --out helm-apps.vsix

      - name: Build happ binaries
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          set -euo pipefail

          cd cmd/happ

          mkdir -p dist

          build_one() {
            local goos="$1"
            local goarch="$2"
            local ext=""
            if [ "$goos" = "windows" ]; then
              ext=".exe"
            fi
            local bin="happ_${goos}_${goarch}${ext}"
            GOOS="$goos" GOARCH="$goarch" CGO_ENABLED=0 go build -trimpath -ldflags="-s -w" -o "dist/${bin}" .
          }

          build_one linux amd64
          build_one linux arm64
          build_one darwin amd64
          build_one darwin arm64
          build_one windows amd64
          build_one windows arm64

      - name: Build happ linux DEB/RPM packages
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          set -euo pipefail

          GOBIN="/tmp/bin" go install github.com/goreleaser/nfpm/v2/cmd/nfpm@v2.41.3
          export PATH="/tmp/bin:${PATH}"

          cd cmd/happ

          package_one() {
            local arch="$1"
            local format="$2"
            local bin_path="dist/happ_linux_${arch}"
            local target="dist/happ_${LIB_VERSION}_linux_${arch}.${format}"
            local staging_dir="dist/.pkg-${arch}"
            local config_path="dist/nfpm_${arch}.yaml"

            mkdir -p "${staging_dir}"
            cp "${bin_path}" "${staging_dir}/happ"

            sed \
              -e "s|__NFPM_ARCH__|${arch}|g" \
              -e "s|__HAPP_VERSION__|${LIB_VERSION}|g" \
              -e "s|__HAPP_BIN__|${staging_dir}/happ|g" \
              packaging/nfpm.yaml > "${config_path}"

            nfpm package \
              --config "${config_path}" \
              --packager "${format}" \
              --target "${target}"
          }

          package_one amd64 deb
          package_one arm64 deb
          package_one amd64 rpm
          package_one arm64 rpm

      - name: Check chart release tag
        id: check_chart_release
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: |
          set -euo pipefail
          TAG="helm-apps-${LIB_VERSION}"
          if gh release view "${TAG}" >/dev/null 2>&1; then
            echo "release_exists=true" >> "${GITHUB_OUTPUT}"
            echo "Release ${TAG} already exists, chart-releaser will be skipped."
          else
            echo "release_exists=false" >> "${GITHUB_OUTPUT}"
            echo "Release ${TAG} does not exist, chart-releaser will run."
          fi

      - name: Run chart-releaser
        if: ${{ github.ref == 'refs/heads/main' && steps.check_chart_release.outputs.release_exists != 'true' }}
        uses: helm/chart-releaser-action@v1.6.0
        with:
          charts_dir: charts
          config: cr.yaml
        env:
          CR_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: Upload happ binaries to GitHub release
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: |
          set -euo pipefail

          TAG="helm-apps-${LIB_VERSION}"

          if ! gh release view "${TAG}" >/dev/null 2>&1; then
            echo "Release ${TAG} not found (nothing new to publish), skipping happ upload."
            exit 0
          fi

          gh release upload "${TAG}" cmd/happ/dist/* --clobber

      - name: Upload extension VSIX to GitHub release
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: |
          set -euo pipefail

          TAG="helm-apps-${LIB_VERSION}"

          if ! gh release view "${TAG}" >/dev/null 2>&1; then
            echo "Release ${TAG} not found (nothing new to publish), skipping extension upload."
            exit 0
          fi

          gh release upload "${TAG}" extensions/helm-apps/helm-apps.vsix --clobber

      - name: Generate and update GitHub release notes
        if: ${{ github.ref == 'refs/heads/main' }}
        env:
          GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
        run: |
          set -euo pipefail

          TAG="helm-apps-${LIB_VERSION}"

          if ! gh release view "${TAG}" >/dev/null 2>&1; then
            echo "Release ${TAG} not found (nothing new to publish), skipping notes update."
            exit 0
          fi

          CHANGELOG_BODY="$(awk -v ver="${LIB_VERSION}" '
            $0 ~ "^## \\[" ver "\\]" {capture=1; next}
            capture && $0 ~ "^## \\[" {exit}
            capture {print}
          ' CHANGELOG.md)"

          if [ -n "${CHANGELOG_BODY}" ]; then
            GENERATED_BODY="${CHANGELOG_BODY}"
          else
            GENERATED_BODY=$(gh api -X POST "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
              -f tag_name="${TAG}" \
              -f target_commitish="${GITHUB_SHA}" \
              --jq '.body')
          fi

          {
            echo "## Helm Apps Library"
            echo
            echo "- Chart: \`helm-apps\`"
            echo "- Version: \`${LIB_VERSION}\`"
            echo
            echo "${GENERATED_BODY}"
          } > /tmp/release_notes.md

          gh release edit "${TAG}" \
            --title "helm-apps ${LIB_VERSION}" \
            --notes-file /tmp/release_notes.md

#    - name: Publish to CR
#      env:
#        CR_PAT: ${{ secrets.CR_PAT }}
#      run: |
#        echo $CR_PAT | helm registry login -u alvnukov  --password-stdin ghcr.io
#        find .cr-release-packages -mindepth 1 -maxdepth 1 -type f -name '*.tgz' -exec sh -c 'basename "$0"' '{}' \; | while read PACKAGE; do
#        helm push .cr-release-packages/$PACKAGE oci://ghcr.io/${GITHUB_REPOSITORY}
#        done
